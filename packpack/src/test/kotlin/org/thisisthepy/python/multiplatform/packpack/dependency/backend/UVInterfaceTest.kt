package org.thisisthepy.python.multiplatform.packpack.dependency.backend

import kotlinx.coroutines.runBlocking
import org.junit.jupiter.api.Test
import org.junit.jupiter.api.BeforeEach
import org.junit.jupiter.api.io.TempDir
import java.io.File
import kotlin.test.assertTrue
import kotlin.test.assertFalse

class UVInterfaceTest {
    
    private lateinit var uvInterface: UVInterface
    
    @TempDir
    lateinit var tempDir: File
    
    @BeforeEach
    fun setUp() {
        uvInterface = UVInterface()
    }
    
    @Test
    fun `test createVirtualEnvironment without platform options`() = runBlocking {
        val venvPath = File(tempDir, "test_venv").absolutePath
        
        val result = uvInterface.createVirtualEnvironment(venvPath, null, null)
        
        // Should succeed without platform-specific options
        assertTrue(result.success, "Virtual environment creation should succeed")
        assertTrue(File(venvPath).exists(), "Virtual environment directory should exist")
        assertTrue(File(venvPath, "pyvenv.cfg").exists(), "pyvenv.cfg should exist")
    }
    
    @Test
    fun `test createVirtualEnvironment with python version`() = runBlocking {
        val venvPath = File(tempDir, "test_venv_py311").absolutePath
        
        val result = uvInterface.createVirtualEnvironment(venvPath, "3.13", null)
        
        assertTrue(result.success, "Virtual environment creation with Python version should succeed")
        assertTrue(File(venvPath).exists(), "Virtual environment directory should exist")
    }
    
    @Test
    fun `test installDependencies without platform options`() = runBlocking {
        // First create a virtual environment
        val venvPath = File(tempDir, "test_venv").absolutePath
        val createResult = uvInterface.createVirtualEnvironment(venvPath, null, null)
        assertTrue(createResult.success, "Virtual environment creation should succeed")
        
        // Install dependencies without platform-specific options
        val dependencies = listOf("requests")
        val result = uvInterface.installDependencies(venvPath, dependencies, null)
        
        assertTrue(result.success, "Dependency installation should succeed without platform options")
    }
    
    @Test
    fun `test exportLockFile generates requirements txt`() = runBlocking {
        // Create a project directory with a simple pyproject.toml
        val projectDir = File(tempDir, "test_project")
        projectDir.mkdirs()
        
        val pyprojectFile = File(projectDir, "pyproject.toml")
        pyprojectFile.writeText("""
            [project]
            name = "test-project"
            version = "0.1.0"
            dependencies = ["requests"]
        """.trimIndent())
        
        // Generate lock file first
        val lockResult = uvInterface.generateLockFile(projectDir.absolutePath, null)
        assertTrue(lockResult.success, "Lock file generation should succeed")
        
        // Export lock file as requirements.txt
        val requirementsPath = File(projectDir, "requirements.txt").absolutePath
        val exportResult = uvInterface.exportLockFile(
            projectDir.absolutePath,
            "requirements-txt",
            requirementsPath,
            null
        )
        
        assertTrue(exportResult.success, "Lock file export should succeed")
        assertTrue(File(requirementsPath).exists(), "Requirements file should be created")
        
        val content = File(requirementsPath).readText()
        assertTrue(content.contains("# This file was autogenerated by uv"), "Requirements file should contain UV header")
    }
    
    @Test
    fun `test syncFromRequirements works correctly`() = runBlocking {
        // Create a virtual environment
        val venvPath = File(tempDir, "test_venv").absolutePath
        val createResult = uvInterface.createVirtualEnvironment(venvPath, null, null)
        assertTrue(createResult.success, "Virtual environment creation should succeed")
        
        // Create a requirements.txt file
        val requirementsFile = File(tempDir, "requirements.txt")
        requirementsFile.writeText("requests==2.31.0\n")
        
        // Sync from requirements file
        val syncResult = uvInterface.syncFromRequirements(
            venvPath,
            requirementsFile.absolutePath,
            null
        )
        
        assertTrue(syncResult.success, "Sync from requirements should succeed")
    }
    
    @Test
    fun `test syncFromLockFile without platform options`() = runBlocking {
        // Create a virtual environment
        val venvPath = File(tempDir, "test_venv").absolutePath
        val createResult = uvInterface.createVirtualEnvironment(venvPath, null, null)
        assertTrue(createResult.success, "Virtual environment creation should succeed")
        
        // Test sync from lock file without platform-specific options
        val syncResult = uvInterface.syncFromLockFile(
            tempDir.absolutePath,
            null,
            mapOf("some-option" to "value") // Should exclude platform options
        )
        
        // Should not fail due to unsupported platform options
        // Note: This might fail for other reasons (no lock file), but not due to platform options
        assertFalse(syncResult.error.contains("--python-platform"), "Should not use unsupported --python-platform option")
    }
    
    @Test
    fun `test showDependencyTree without platform options`() = runBlocking {
        // Create a virtual environment
        val venvPath = File(tempDir, "test_venv").absolutePath
        val createResult = uvInterface.createVirtualEnvironment(venvPath, null, null)
        assertTrue(createResult.success, "Virtual environment creation should succeed")
        
        // Show dependency tree without platform-specific options
        val treeResult = uvInterface.showDependencyTree(venvPath, null)
        
        // Should not fail due to unsupported platform options
        assertFalse(treeResult.error.contains("--platform"), "Should not use unsupported --platform option")
    }
    
    @Test
    fun `test syncDependencies without platform options`() = runBlocking {
        // Create a virtual environment
        val venvPath = File(tempDir, "test_venv").absolutePath
        val createResult = uvInterface.createVirtualEnvironment(venvPath, null, null)
        assertTrue(createResult.success, "Virtual environment creation should succeed")
        
        // Sync dependencies without platform-specific options
        val syncResult = uvInterface.syncDependencies(venvPath, null)
        
        // Should not fail due to unsupported platform options
        assertFalse(syncResult.error.contains("--platform"), "Should not use unsupported --platform option")
    }
    
    @Test
    fun `test uninstallDependencies without platform options`() = runBlocking {
        // Create a virtual environment and install a dependency first
        val venvPath = File(tempDir, "test_venv").absolutePath
        val createResult = uvInterface.createVirtualEnvironment(venvPath, null, null)
        assertTrue(createResult.success, "Virtual environment creation should succeed")
        
        val installResult = uvInterface.installDependencies(venvPath, listOf("requests"), null)
        assertTrue(installResult.success, "Dependency installation should succeed")
        
        // Uninstall dependencies without platform-specific options
        val uninstallResult = uvInterface.uninstallDependencies(venvPath, listOf("requests"), null)
        
        // Should not fail due to unsupported platform options (may fail for other reasons like package not found)
        assertFalse(uninstallResult.error.contains("--platform"), "Should not use unsupported --platform option")
    }
} 